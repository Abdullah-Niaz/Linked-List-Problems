Find out the mid node & make it a root
root -> left = t1 
root -> right = t2 
return root


1. Traverse the linked list 
2. count & divide by 2 to take the mid 
3. make the that as a root
	root = new Treenode(o);
	root->left = maketree(left)
	root->right= maketree(right)




second approach is Here & tortose
1. Take two pointers 
	slow = head
	fast = head
2. Move the slow pointer by 1
3. Move the head poitner by 2
4  slow pointer will always be at the mid 

  

        // if the root is null 
        if(!head){
            return NULL;
        }

        if(!head->next){
            return new TreeNode(head->val);
        }

        ListNode *slow = head;
        ListNode *fast = head;
        ListNode *slow_prev = NULL;

        while(fast != NULL && fast->next !=NULL){
            slow_prev = slow;
            slow = slow->next;
            fast = fast->next->next;
        }

        // slow will always be at the mid
        TreeNode *root = new TreeNode(slow->val);

        slow_prev->next = NULL;

        root->left = sortedListToBST(head);
        root->right = sortedListToBST(slow->next);
        
        
        return root;